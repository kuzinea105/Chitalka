{
  "name": "Chitalka",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "chitalka",
        "options": {
          "noResponseBody": true
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -688,
        -192
      ],
      "id": "0ac7266e-6920-416c-b052-235cc62a4b6c",
      "name": "Webhook",
      "webhookId": "8391a12d-1196-4427-9fcf-f9f2332a0851"
    },
    {
      "parameters": {
        "jsCode": "// Extract message — FULL REPLACE v3 (adds audio detection + hasAudio)\n// Input: $json.body.updates[0]\n// Output: { text, chatId, login, hasFile, hasAudio, files[] }\n\nfunction normalizeText(s) {\n  return String(s || '').replace(/\\u00A0/g, ' ').trim();\n}\n\nfunction toArrayMaybe(x) {\n  if (!x) return [];\n  if (Array.isArray(x)) return x;\n  return [x];\n}\n\nfunction uniqPushFile(arr, f) {\n  const kind = String(f.kind || '');\n  const id = String(f.file_id || f.id || '');\n  const key = `${kind}|${id}`;\n  if (!id) return;\n  if (arr._seen && arr._seen.has(key)) return;\n  arr._seen = arr._seen || new Set();\n  arr._seen.add(key);\n  arr.push(f);\n}\n\nfunction guessKindByName(name) {\n  const n = String(name || '').toLowerCase();\n  if (/\\.(png|jpg|jpeg|bmp|gif|tif|tiff|webp)$/i.test(n)) return 'image';\n  if (/\\.(ogg|opus|mp3|wav|m4a|aac|flac)$/i.test(n)) return 'audio';\n  return 'file';\n}\n\nconst update = $json?.body?.updates?.[0];\nif (!update) return [];\n\nconst text = normalizeText(update.text || '') || 'Empty';\n\n// chatId/login\nconst chatId = update?.from?.id ?? update?.chat?.id ?? null;\nconst login = update?.from?.login ?? null;\n\nconst files = [];\n\n// images can come in different shapes: images[0] array, images array, or object\nconst imagesRaw = update.images;\nif (imagesRaw) {\n  // sometimes images is [[...]] or [...]\n  const imgs = Array.isArray(imagesRaw) && Array.isArray(imagesRaw[0]) ? imagesRaw[0] : imagesRaw;\n  for (const src of toArrayMaybe(imgs)) {\n    if (!src) continue;\n    const file_id = src.file_id || src.id;\n    uniqPushFile(files, {\n      kind: 'image',\n      file_id,\n      name: src.name || '',\n      size: src.size,\n      width: src.width,\n      height: src.height,\n    });\n  }\n}\n\n// generic file (docs, logs, voice, etc)\nif (update.file) {\n  const f = update.file;\n  const file_id = f.file_id || f.id;\n  const name = f.name || '';\n  const kind = guessKindByName(name);\n  uniqPushFile(files, {\n    kind,\n    file_id,\n    name,\n    size: f.size,\n  });\n}\n\nconst hasFile = files.length > 0;\nconst hasAudio = files.some(f => String(f.kind).toLowerCase() === 'audio');\n\nreturn [{\n  json: {\n    text,\n    chatId,\n    login,\n    hasFile,\n    hasAudio,\n    files,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -528,
        -192
      ],
      "id": "9e7fac45-4c47-4f08-b8d9-547182ee73cb",
      "name": "Extract message"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "64Y6oJPQRzpKmBIv",
          "mode": "list",
          "cachedResultName": "Yandex_messages",
          "cachedResultUrl": "/projects/NzQv03hxe8w3kPzF/datatables/64Y6oJPQRzpKmBIv"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "processed": false,
            "chatId": "={{$json.chatId}}",
            "timestamp": "={{Date.now()}}",
            "text": "={{$json.text}}",
            "files": "={{ JSON.stringify($json.files || []) }}",
            "login": "={{$json.login}}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "chatId",
              "displayName": "chatId",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "timestamp",
              "displayName": "timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "text",
              "displayName": "text",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "processed",
              "displayName": "processed",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "boolean",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "files",
              "displayName": "files",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "login",
              "displayName": "login",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {
          "optimizeBulk": false
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -352,
        -192
      ],
      "id": "89b3ec39-d96a-4f47-a15d-5a2a45ee15a6",
      "name": "Data message"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "64Y6oJPQRzpKmBIv",
          "mode": "list",
          "cachedResultName": "Yandex_messages",
          "cachedResultUrl": "/projects/NzQv03hxe8w3kPzF/datatables/64Y6oJPQRzpKmBIv"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "chatId",
              "keyValue": "={{$json.chatId}}"
            },
            {
              "keyName": "processed",
              "condition": "isFalse"
            }
          ]
        },
        "returnAll": true
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -160,
        -192
      ],
      "id": "fc3c7cba-bac1-4500-bea9-9b6a1f266d3c",
      "name": "Read messages"
    },
    {
      "parameters": {
        "operation": "update",
        "dataTableId": {
          "__rl": true,
          "value": "64Y6oJPQRzpKmBIv",
          "mode": "list",
          "cachedResultName": "Yandex_messages",
          "cachedResultUrl": "/projects/NzQv03hxe8w3kPzF/datatables/64Y6oJPQRzpKmBIv"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "chatId",
              "keyValue": "={{$json.chatId}}"
            },
            {
              "keyName": "processed",
              "condition": "isFalse"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "processed": true
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "chatId",
              "displayName": "chatId",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": true
            },
            {
              "id": "timestamp",
              "displayName": "timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": true
            },
            {
              "id": "text",
              "displayName": "text",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": true
            },
            {
              "id": "processed",
              "displayName": "processed",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "boolean",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "files",
              "displayName": "files",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": true
            },
            {
              "id": "login",
              "displayName": "login",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        784,
        -448
      ],
      "id": "0e610d65-c42f-486d-95d9-44f3298da379",
      "name": "Update row(s)",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Code node \"Stop\"\n// Ничего не делаем и останавливаем цепочку для этих сообщений\nreturn [];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        944,
        288
      ],
      "id": "1f4f3525-cda9-4032-9a2a-ad0fab4c4516",
      "name": "Stop"
    },
    {
      "parameters": {
        "jsCode": "// Prepare files for OCR — FULL REPLACE v3 (force ORIGINAL file_id, no leader logic)\n// Input: $json.files may be array OR JSON-string\n// Output: preserves base, sets file_id/file_name and _ocrChosen debug\n\nfunction parseFiles(v) {\n  if (!v) return [];\n  if (Array.isArray(v)) return v;\n  if (typeof v === 'string') {\n    try { const a = JSON.parse(v); return Array.isArray(a) ? a : []; } catch { return []; }\n  }\n  return [];\n}\n\nfunction isImage(f) {\n  if (!f || typeof f !== 'object') return false;\n  const kind = String(f.kind || '').toLowerCase();\n  if (kind === 'image') return true;\n  const name = String(f.name || '').toLowerCase();\n  return /\\.(png|jpg|jpeg|bmp|gif|tif|tiff|webp)$/i.test(name);\n}\n\nconst base = $input.item.json || {};\nconst files = parseFiles(base.files).filter(isImage);\n\nif (!files.length) {\n  return [{\n    json: {\n      ...base,\n      _skipOcr: true,\n      file_id: '',\n      file_name: '',\n      _ocrChosen: null,\n    }\n  }];\n}\n\n// Prefer ORIGINAL: file_id without \"?size=\"\nconst originals = files.filter(f => String(f.file_id || f.id || '').includes('?size=') === false);\nlet cand = null;\n\nfunction area(f) {\n  const w = Number(f.width || 0);\n  const h = Number(f.height || 0);\n  return (isFinite(w) ? w : 0) * (isFinite(h) ? h : 0);\n}\n\nconst pool = originals.length ? originals : files;\n\n// Pick max area, fallback last\npool.sort((a,b) => area(b) - area(a));\ncand = pool[0] || pool[pool.length - 1];\n\nconst fid = String(cand.file_id || cand.id || '').trim();\nconst fname = (String(cand.name || '').trim()) || 'image.png';\n\nreturn [{\n  json: {\n    ...base,\n    _skipOcr: false,\n    file_id: fid,\n    file_name: fname,\n    file_kind: 'image',\n    _ocrChosen: {\n      file_id: fid,\n      name: fname,\n      width: cand.width || null,\n      height: cand.height || null,\n      originalPreferred: originals.length > 0,\n    }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1024,
        -336
      ],
      "id": "4ef3daf9-c9be-4c6f-a549-ca70499ef084",
      "name": "Prepare files for OCR"
    },
    {
      "parameters": {
        "jsCode": "// Merge OCR results — FULL REPLACE v4 (KEEP BASE FIELDS)\n// Goal: preserve chatId/login/file_id/file_name/etc downstream.\n// Input: items from \"OCR Request\" (each has ...base + ok/text/ocr_text)\n// Output: single item: { ...base, ok, ocr_text, files }\n\nconst inItems = $input.all();\nif (!inItems.length) {\n  return [{ json: { ok: false, ocr_text: '', files: [], note: '[ocr] no results' } }];\n}\n\n// base from first item (contains chatId/login + chosen file_id/file_name, etc.)\nconst base = (inItems[0] && inItems[0].json) ? inItems[0].json : {};\n\nfunction pickText(res) {\n  return String((res && (res.ocr_text ?? res.text ?? '')) || '').trim();\n}\nfunction pickOk(res) {\n  return res && res.ok === true;\n}\nfunction pickErr(res) {\n  return String((res && (res.error_data || res.error || '')) || '').trim();\n}\n\nlet allOk = true;\nconst parts = [];\nconst files = [];\n\nfor (const it of inItems) {\n  const res = it.json || {};\n  const name = String(res.file_name || res.file_id || res.id || '(no-name)').trim() || '(no-name)';\n  const text = pickText(res);\n  const ok = pickOk(res) && text.length > 0;\n  const err = pickErr(res);\n\n  if (!ok) allOk = false;\n\n  files.push({\n    name,\n    ok,\n    text,\n    err,\n    debug: res.ocr_debug || null,\n  });\n\n  if (text) parts.push(`Файл \"${name}\":\\n${text}`);\n  else if (err) parts.push(`Файл \"${name}\":\\n[OCR ERROR]\\n${err}`);\n  else parts.push(`Файл \"${name}\":\\n[OCR] Empty result (text not recognized).`);\n}\n\nreturn [{\n  json: {\n    ...base,\n    ok: allOk,\n    ocr_text: parts.join('\\n\\n'),\n    files,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1408,
        -336
      ],
      "id": "621a8203-702e-4f58-9203-58506b4add24",
      "name": "Merge OCR results"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://botapi.messenger.yandex.net/bot/v1/messages/sendText/",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "OAuth y0__xDstZLTCBiWkRMg4du1jxZE-buUAzc_9dglUhY1u72T5ydTzA"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "login",
              "value": "={{$json.login}}"
            },
            {
              "name": "text",
              "value": "={{$json.text}}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        2928,
        -80
      ],
      "id": "93abf3a4-dccc-4f02-975b-07ffabe63573",
      "name": "Send Text"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://botapi.messenger.yandex.net/bot/v1/messages/sendFile/",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "OAuth y0__xDstZLTCBiWkRMg4du1jxZE-buUAzc_9dglUhY1u72T5ydTzA"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "login",
              "value": "={{$json.login}}"
            },
            {
              "parameterType": "formBinaryData",
              "name": "document",
              "inputDataFieldName": "file"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        2928,
        -304
      ],
      "id": "4bd1e1af-18eb-4465-adf6-c98ff133728d",
      "name": "Send file"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "15527451-ad55-4b9e-a7e4-5db6dfdfe946",
              "leftValue": "={{ !!$binary.file }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2448,
        -192
      ],
      "id": "c3bca3af-c29a-40f5-a13b-4460b40f247e",
      "name": "If file"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "36faeef7-d542-4c14-bf69-9c8d27e60531",
              "leftValue": "={{ $json.route === 'ocr' }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        784,
        -208
      ],
      "id": "c704d7b0-9774-496b-be02-6671bb462568",
      "name": "Files go OCR"
    },
    {
      "parameters": {
        "jsCode": "// VLM Normalize (Qwen2.5-VL) — FULL REPLACE v3 (image-first, fix OCR mistakes, keep chatId/login)\n// Requires: env YANDEX_BOT_TOKEN, OLLAMA_URL (or default), model qwen2.5vl:72b-q8_0\n// Input expected: base.file_id + base.file_name + base.ocr_text + base.chatId/login\n\nconst https = require('https');\n\nconst base = $input.item.json || {};\nconst OLLAMA_URL = (String($env.OLLAMA_URL || 'http://host.docker.internal:11434')).replace(/\\/$/, '');\nconst MODEL = 'qwen2.5vl:72b-q8_0';\n\nfunction s(x){ return x == null ? '' : String(x); }\n\nfunction httpRequestBuffer({ method, hostname, path, headers }, bodyBuf) {\n  return new Promise((resolve, reject) => {\n    const req = https.request({ method, hostname, path, headers }, (res) => {\n      const chunks = [];\n      res.on('data', (d) => chunks.push(Buffer.isBuffer(d) ? d : Buffer.from(d)));\n      res.on('end', () => resolve({ statusCode: res.statusCode || 0, headers: res.headers || {}, buf: Buffer.concat(chunks) }));\n    });\n    req.on('error', reject);\n    if (bodyBuf && bodyBuf.length) req.write(bodyBuf);\n    req.end();\n  });\n}\n\nfunction looksLikeJson(headers, buf) {\n  const ct = String((headers && headers['content-type']) || '').toLowerCase();\n  if (ct.includes('application/json')) return true;\n  const b0 = (buf && buf.slice && buf.slice(0, 1).toString('utf8')) || '';\n  return b0 === '{' || b0 === '[';\n}\n\nfunction extractYandexJsonError(buf) {\n  try {\n    const obj = JSON.parse(buf.toString('utf8'));\n    if (obj && obj.ok === false) return obj.description || obj.code || 'getFile failed';\n  } catch {}\n  return null;\n}\n\nasync function yandexGetFileBuffer(fileId) {\n  const token = String(($env && $env.YANDEX_BOT_TOKEN) || '').trim();\n  if (!token) throw new Error('YANDEX_BOT_TOKEN is not set');\n  if (!fileId) throw new Error('file_id is empty');\n\n  const body = Buffer.from(JSON.stringify({ file_id: fileId }), 'utf8');\n\n  const r1 = await httpRequestBuffer(\n    {\n      method: 'POST',\n      hostname: 'botapi.messenger.yandex.net',\n      path: '/bot/v1/messages/getFile/',\n      headers: {\n        'Authorization': `OAuth ${token}`,\n        'Content-Type': 'application/json',\n        'Content-Length': String(body.length),\n      },\n    },\n    body\n  );\n\n  if (looksLikeJson(r1.headers, r1.buf)) {\n    const err = extractYandexJsonError(r1.buf);\n    if (err) throw new Error(err);\n  }\n  if (r1.statusCode >= 200 && r1.statusCode < 300) return r1.buf;\n\n  const p = `/bot/v1/messages/getFile/?file_id=${encodeURIComponent(fileId)}`;\n  const r2 = await httpRequestBuffer(\n    { method: 'GET', hostname: 'botapi.messenger.yandex.net', path: p, headers: { 'Authorization': `OAuth ${token}` } },\n    null\n  );\n\n  if (looksLikeJson(r2.headers, r2.buf)) {\n    const err = extractYandexJsonError(r2.buf);\n    if (err) throw new Error(err);\n  }\n  if (r2.statusCode >= 200 && r2.statusCode < 300) return r2.buf;\n\n  throw new Error(`getFile failed: POST=${r1.statusCode} GET=${r2.statusCode}`);\n}\n\nfunction extractJsonLoose(text) {\n  const t = String(text || '').trim()\n    .replace(/^```json\\s*/i, '')\n    .replace(/^```\\s*/i, '')\n    .replace(/```$/i, '')\n    .trim();\n  try { return JSON.parse(t); } catch {}\n  const m = t.match(/\\{[\\s\\S]*\\}/);\n  if (m) { try { return JSON.parse(m[0]); } catch {} }\n  return null;\n}\n\n// ---- main ----\nconst fileId = s(base.file_id || base.fileId).trim();\nconst fileName = s(base.file_name || base.fileName || 'image.png').trim();\nconst ocrText = s(base.ocr_text || '').trim();\n\nif (!fileId) {\n  return [{ json: { ...base, vlm_ok: false, vlm_error: 'file_id missing' } }];\n}\n\n// download original image (must be the best candidate chosen upstream)\nconst imgBuf = await yandexGetFileBuffer(fileId);\nconst imgB64 = imgBuf.toString('base64');\n\nconst prompt = `ROLE: DOCUMENT TEXT NORMALIZER (NOT A CHATBOT)\n\nSOURCE OF TRUTH:\n- IMAGE is authoritative.\n- OCR_HINT is noisy. If OCR_HINT conflicts with IMAGE, ALWAYS follow IMAGE.\n\nTASK:\n1) Transcribe EXACT text from IMAGE.\n2) Fix obvious OCR mistakes using IMAGE (e.g. duplicated syllables/letters: \"Словарарный\" -> \"Словарный\" if the image shows it).\n3) Preserve punctuation, commas, \"№\", capitalization, and line breaks as in IMAGE.\n4) Preserve stress marks (acute accents) exactly as shown in IMAGE.\n5) Do not invent words.\n\nOUTPUT:\nReturn ONLY valid JSON (no markdown, no commentary).\n\nJSON schema:\n{\n  \"lang\": \"ru|en|mixed\",\n  \"doc_type\": \"screenshot|worksheet|invoice|contract|act|letter|table|other\",\n  \"normalized_text\": \"exact reconstructed text with line breaks\",\n  \"key_values\": {},\n  \"tables\": [],\n  \"notes\": \"\"\n}\n\nOCR_HINT (may contain errors):\n${ocrText ? ocrText.slice(0, 15000) : '(none)'}\n`;\n\nlet resp;\ntry {\n  resp = await this.helpers.httpRequest({\n    method: 'POST',\n    url: `${OLLAMA_URL}/api/chat`,\n    json: true,\n    timeout: 3600000,\n    body: {\n      model: MODEL,\n      stream: false,\n      options: { temperature: 0, top_p: 1, top_k: 1 },\n      messages: [{\n        role: 'user',\n        content: prompt,\n        images: [imgB64],\n      }],\n    },\n  });\n} catch (e) {\n  return [{ json: { ...base, vlm_ok: false, vlm_error: `LLM request failed: ${e.message || e}` } }];\n}\n\nconst content = (resp && resp.message && resp.message.content) ? resp.message.content : '';\nconst obj = extractJsonLoose(content);\n\nreturn [{\n  json: {\n    ...base,\n    vlm_ok: true,\n    vlm_model: MODEL,\n    vlm_raw: content,\n    vlm_json: obj || null,\n    vlm_text: (obj && obj.normalized_text) ? String(obj.normalized_text) : '',\n    vlm_tables: (obj && obj.tables) ? obj.tables : [],\n    vlm_kv: (obj && obj.key_values) ? obj.key_values : {},\n    // keep recipient explicit\n    chatId: base.chatId,\n    login: base.login,\n    _vlm_input_file: { file_id: fileId, file_name: fileName, bytes: imgBuf.length },\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1792,
        -336
      ],
      "id": "06810417-ee28-4b30-aeba-698e389c0783",
      "name": "VLM Normalize (Qwen2.5-VL)"
    },
    {
      "parameters": {
        "jsCode": "// OCR Request — FULL REPLACE v5.5 (fail-fast URL, clearer errors)\n// Env: YANDEX_BOT_TOKEN_CHITALKA\n// OCR_URL default: http://host.docker.internal:8000/ocr-image\n// OCR_URL_EN default: http://host.docker.internal:8000/ocr-image-en\n\nconst https = require('https');\n\nconst base = $input.item.json || {};\nconst fileId = String(base.file_id || '').trim();\nconst fileName = String(base.file_name || 'image.png').trim() || 'image.png';\n\n\nconst OCR_URL = String($env.OCR_URL || 'http://host.docker.internal:8000/ocr-image').replace(/\\/$/, '');\nconst OCR_URL_EN = String($env.OCR_URL_EN || 'http://host.docker.internal:8000/ocr-image-en').replace(/\\/$/, '');\n\nif (!OCR_URL) {\n  return [{ json: { ...base, ok: false, ocr_text: '', text: '', error: 'OCR_URL is not set', ocr_debug: { url: OCR_URL } } }];\n}\n\nfunction httpRequestBuffer({ method, hostname, path, headers }, bodyBuf) {\n  return new Promise((resolve, reject) => {\n    const req = https.request({ method, hostname, path, headers }, (res) => {\n      const chunks = [];\n      res.on('data', (d) => chunks.push(Buffer.isBuffer(d) ? d : Buffer.from(d)));\n      res.on('end', () => resolve({ statusCode: res.statusCode || 0, headers: res.headers || {}, buf: Buffer.concat(chunks) }));\n    });\n    req.on('error', reject);\n    if (bodyBuf && bodyBuf.length) req.write(bodyBuf);\n    req.end();\n  });\n}\n\nfunction looksLikeJson(headers, buf) {\n  const ct = String((headers && headers['content-type']) || '').toLowerCase();\n  if (ct.includes('application/json')) return true;\n  const b0 = (buf && buf.slice && buf.slice(0, 1).toString('utf8')) || '';\n  return b0 === '{' || b0 === '[';\n}\n\nfunction extractYandexJsonError(buf) {\n  try {\n    const obj = JSON.parse(buf.toString('utf8'));\n    if (obj && obj.ok === false) return obj.description || obj.code || 'getFile failed';\n  } catch {}\n  return null;\n}\n\nasync function yandexGetFileBuffer(fid) {\n  const token = String(($env && $env.YANDEX_BOT_TOKEN_CHITALKA) || '').trim();\n  if (!token) throw new Error('YANDEX_BOT_TOKEN_CHITALKA is not set');\n  if (!fid) throw new Error('file_id is empty');\n\n  const body = Buffer.from(JSON.stringify({ file_id: fid }), 'utf8');\n\n  const r1 = await httpRequestBuffer(\n    {\n      method: 'POST',\n      hostname: 'botapi.messenger.yandex.net',\n      path: '/bot/v1/messages/getFile/',\n      headers: {\n        'Authorization': `OAuth ${token}`,\n        'Content-Type': 'application/json',\n        'Content-Length': String(body.length),\n      },\n    },\n    body\n  );\n\n  if (looksLikeJson(r1.headers, r1.buf)) {\n    const err = extractYandexJsonError(r1.buf);\n    if (err) throw new Error(err);\n  }\n  if (r1.statusCode >= 200 && r1.statusCode < 300) return r1.buf;\n\n  const p = `/bot/v1/messages/getFile/?file_id=${encodeURIComponent(fid)}`;\n  const r2 = await httpRequestBuffer(\n    { method: 'GET', hostname: 'botapi.messenger.yandex.net', path: p, headers: { 'Authorization': `OAuth ${token}` } },\n    null\n  );\n\n  if (looksLikeJson(r2.headers, r2.buf)) {\n    const err = extractYandexJsonError(r2.buf);\n    if (err) throw new Error(err);\n  }\n  if (r2.statusCode >= 200 && r2.statusCode < 300) return r2.buf;\n\n  throw new Error(`getFile failed: POST=${r1.statusCode} | GET=${r2.statusCode}`);\n}\n\nfunction guessMime(name) {\n  const n = String(name || '').toLowerCase();\n  if (n.endsWith('.png')) return 'image/png';\n  if (n.endsWith('.jpg') || n.endsWith('.jpeg')) return 'image/jpeg';\n  if (n.endsWith('.webp')) return 'image/webp';\n  return 'application/octet-stream';\n}\n\nfunction safeJson(v) {\n  try { return JSON.stringify(v); } catch { return String(v); }\n}\n\nfunction extractText(obj) {\n  function isBadToken(t) {\n    const x = String(t || '').trim().toLowerCase();\n    return x === 'ru' || x === 'en' || x === 'ok' || x === 'true' || x === 'false';\n  }\n\n  function walk(x) {\n    if (x == null) return '';\n    if (typeof x === 'string') {\n      const t = x.trim();\n      if (!t) return '';\n      if (isBadToken(t)) return '';\n      if (t.length < 3) return '';\n      return t;\n    }\n    if (Array.isArray(x)) {\n      const parts = [];\n      for (const v of x) {\n        const t = walk(v);\n        if (t) parts.push(t);\n      }\n      return parts.join('\\n').trim();\n    }\n    if (typeof x === 'object') {\n      const keys = ['text','ocr_text','result','body','data','content'];\n      for (const k of keys) {\n        if (x[k] != null) {\n          const t = walk(x[k]);\n          if (t) return t;\n        }\n      }\n      if (x.results != null) {\n        const t = walk(x.results);\n        if (t) return t;\n      }\n      return '';\n    }\n    return '';\n  }\n\n  return walk(obj);\n}\n\nfunction addLangToUrl(url, lang) {\n  if (!lang) return url;\n  return url.includes('?') ? `${url}&lang=${encodeURIComponent(lang)}` : `${url}?lang=${encodeURIComponent(lang)}`;\n}\n\nasync function httpFullResponse(options) {\n  const full = await this.helpers.httpRequest({\n    ...options,\n    json: false,\n    simple: false,\n    resolveWithFullResponse: true,\n  });\n  const status = full.statusCode || 0;\n  const bodyStr = Buffer.isBuffer(full.body) ? full.body.toString('utf8') : String(full.body || '');\n  return { status, bodyStr };\n}\n\nif (!fileId) {\n  return [{ json: { ...base, ok: false, ocr_text: '', text: '', error: 'file_id missing' } }];\n}\n\nlet imgBuf;\ntry {\n  imgBuf = await yandexGetFileBuffer(fileId);\n} catch (e) {\n  return [{ json: { ...base, ok: false, ocr_text: '', text: '', error: `Download image failed: ${e.message || e}` } }];\n}\n\nconst mime = guessMime(fileName);\nconst b64 = imgBuf.toString('base64');\n\nconst ocrLang = String(base.ocr_lang || '').toLowerCase();\nconst useEn = ocrLang.startsWith('en') || base.forceOcrEn === true;\nconst baseUrl = useEn ? OCR_URL_EN : OCR_URL;\n\nconst urlVariants = useEn ? [baseUrl] : [baseUrl, addLangToUrl(baseUrl, 'ru')];\nconst attempts = [];\n\nconst mpFields = ['image', 'file', 'document', 'upload', 'img'];\nconst jsonKeys = ['image_b64', 'img_b64', 'data_b64', 'base64', 'image', 'file_b64', 'file', 'content'];\nconst langVariants = useEn ? [null] : ['ru', null];\n\nfor (const baseUrlVariant of urlVariants) {\n  for (const lang of langVariants) {\n    // multipart\n    for (const field of mpFields) {\n      try {\n        const formData = {};\n        if (lang) formData.lang = lang;\n        formData[field] = { value: imgBuf, options: { filename: fileName, contentType: mime } };\n\n        const { status, bodyStr } = await httpFullResponse.call(this, {\n          method: 'POST',\n          url: baseUrlVariant,\n          formData,\n          timeout: 180000,\n        });\n\n        attempts.push({ kind: 'multipart', url: baseUrlVariant, field, lang, status, bodyHead: bodyStr.slice(0, 200) });\n\n        if (status >= 200 && status < 300) {\n          const parsed = (() => { try { return JSON.parse(bodyStr); } catch { return bodyStr; } })();\n          const text = extractText(parsed);\n          return [{\n            json: {\n              ...base,\n              ok: !!text,\n              ocr_text: text,\n              text,\n              file_id: fileId,\n              file_name: fileName,\n              ocr_debug: { url: baseUrlVariant, bytes: imgBuf.length, mime, chosen: { kind: 'multipart', field, lang }, attempts },\n            }\n          }];\n        }\n      } catch (e) {\n        attempts.push({ kind: 'multipart', url: baseUrlVariant, field, lang, error: String(e?.message || e).slice(0, 200) });\n      }\n    }\n\n    // json base64\n    for (const key of jsonKeys) {\n      try {\n        const body = { [key]: b64 };\n        if (lang) body.lang = lang;\n        const { status, bodyStr } = await httpFullResponse.call(this, {\n          method: 'POST',\n          url: baseUrlVariant,\n          body: JSON.stringify(body),\n          headers: { 'Content-Type': 'application/json' },\n          timeout: 180000,\n        });\n\n        attempts.push({ kind: 'json', url: baseUrlVariant, key, lang, status, bodyHead: bodyStr.slice(0, 200) });\n\n        if (status >= 200 && status < 300) {\n          const parsed = (() => { try { return JSON.parse(bodyStr); } catch { return bodyStr; } })();\n          const text = extractText(parsed);\n          return [{\n            json: {\n              ...base,\n              ok: !!text,\n              ocr_text: text,\n              text,\n              file_id: fileId,\n              file_name: fileName,\n              ocr_debug: { url: baseUrlVariant, bytes: imgBuf.length, mime, chosen: { kind: 'json', key, lang }, attempts },\n            }\n          }];\n        }\n      } catch (e) {\n        attempts.push({ kind: 'json', url: baseUrlVariant, key, lang, error: String(e?.message || e).slice(0, 200) });\n      }\n    }\n\n    // raw body\n    try {\n      const rawUrl = lang ? addLangToUrl(baseUrlVariant, lang) : baseUrlVariant;\n      const { status, bodyStr } = await httpFullResponse.call(this, {\n        method: 'POST',\n        url: rawUrl,\n        body: imgBuf,\n        headers: { 'Content-Type': mime },\n        timeout: 180000,\n      });\n\n      attempts.push({ kind: 'raw', url: rawUrl, lang, status, bodyHead: bodyStr.slice(0, 200) });\n\n      if (status >= 200 && status < 300) {\n        const parsed = (() => { try { return JSON.parse(bodyStr); } catch { return bodyStr; } })();\n        const text = extractText(parsed);\n        return [{\n          json: {\n            ...base,\n            ok: !!text,\n            ocr_text: text,\n            text,\n            file_id: fileId,\n            file_name: fileName,\n            ocr_debug: { url: rawUrl, bytes: imgBuf.length, mime, chosen: { kind: 'raw', lang }, attempts },\n          }\n        }];\n      }\n    } catch (e) {\n      attempts.push({ kind: 'raw', url: baseUrlVariant, lang, error: String(e?.message || e).slice(0, 200) });\n    }\n  }\n}\n\nreturn [{\n  json: {\n    ...base,\n    ok: false,\n    ocr_text: '',\n    text: '',\n    error: 'OCR HTTP failed (all variants). See ocr_debug.attempts',\n    error_data: safeJson(attempts).slice(0, 3000),\n    ocr_debug: { url: baseUrl, bytes: imgBuf.length, mime, attempts },\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1248,
        -336
      ],
      "id": "492663e3-149c-4d4b-8c11-9d719f4ce615",
      "name": "OCR Request"
    },
    {
      "parameters": {
        "jsCode": "// Chitalka Extract PDF/TXT — FULL REPLACE v4.3 (JSON base64 to sidecar + ALWAYS error_data)\n// Sidecar: http://chitalka-tools:8097/pdf/extract  (JSON: {pdf_b64, lang})\n// Env: YANDEX_BOT_TOKEN_CHITALKA\n//\n// Success: ...base + source_file_name + ocr_text + _pdf_ok + _pdf_debug\n// Error:   ...base + _chitalka_no_doc=true + error + error_data (+ _getfile_debug + _pdf_send_debug)\n\nconst https = require('https');\nconst base = $input.item.json || {};\nconst PDF_EXTRACT_URL = String($env.PDF_EXTRACT_URL || 'http://chitalka-tools:8097/pdf/extract').trim();\n\nfunction s(x){ return x == null ? '' : String(x); }\n\nfunction parseFiles(v) {\n  if (!v) return [];\n  if (Array.isArray(v)) return v;\n  if (typeof v === 'string') {\n    try { const a = JSON.parse(v); return Array.isArray(a) ? a : []; } catch { return []; }\n  }\n  return [];\n}\n\nfunction isImageFile(f) {\n  const kind = String((f && f.kind) || '').toLowerCase();\n  if (kind === 'image') return true;\n  const name = String((f && f.name) || '').toLowerCase();\n  return /\\.(png|jpg|jpeg|bmp|gif|tif|tiff|webp)$/i.test(name);\n}\nfunction isAudioFile(f) {\n  const kind = String((f && f.kind) || '').toLowerCase();\n  if (kind === 'audio') return true;\n  const name = String((f && f.name) || '').toLowerCase();\n  return /\\.(ogg|opus|mp3|wav|m4a|aac|flac)$/i.test(name);\n}\n\nfunction pickNonImage(filesArr) {\n  const non = filesArr.filter(f => f && !isImageFile(f) && !isAudioFile(f));\n  if (!non.length) return null;\n  const pdf = non.filter(f => /\\.pdf$/i.test(String(f.name || '')));\n  return pdf.length ? pdf[pdf.length - 1] : non[non.length - 1];\n}\n\nfunction httpsRequestBuffer(hostname, pathStr, method, headers, bodyBuf) {\n  return new Promise((resolve, reject) => {\n    const req = https.request({ method, hostname, path: pathStr, headers: headers || {} }, (res) => {\n      const chunks = [];\n      res.on('data', (d) => chunks.push(Buffer.isBuffer(d) ? d : Buffer.from(d)));\n      res.on('end', () => resolve({ statusCode: res.statusCode || 0, headers: res.headers || {}, buf: Buffer.concat(chunks) }));\n    });\n    req.on('error', reject);\n    if (bodyBuf && bodyBuf.length) req.write(bodyBuf);\n    req.end();\n  });\n}\n\nfunction looksLikeJson(headers, buf) {\n  const ct = String((headers && headers['content-type']) || '').toLowerCase();\n  if (ct.includes('application/json')) return true;\n  const b0 = (buf && buf.slice && buf.slice(0,1).toString('utf8')) || '';\n  return b0 === '{' || b0 === '[';\n}\nfunction tryParseJson(buf) {\n  try { return JSON.parse(buf.toString('utf8')); } catch { return null; }\n}\nfunction preview(buf, limit) {\n  try { return buf.toString('utf8', 0, limit || 220); } catch { return ''; }\n}\n\nasync function downloadByUrl(url) {\n  const b = await this.helpers.httpRequest({\n    method: 'GET',\n    url,\n    encoding: null,\n    json: false,\n    timeout: 180000\n  });\n  return Buffer.isBuffer(b) ? b : Buffer.from(b);\n}\n\nasync function yandexGetFileBuffer(fileId) {\n  const token = String(($env && $env.YANDEX_BOT_TOKEN_CHITALKA) || '').trim();\n  if (!token) throw new Error('YANDEX_BOT_TOKEN_CHITALKA is not set');\n  if (!fileId) throw new Error('file_id is empty');\n\n  const debug = [];\n  const body = Buffer.from(JSON.stringify({ file_id: fileId }), 'utf8');\n\n  async function attempt(method, apiPath, bodyBufOrNull) {\n    const headers = { 'Authorization': `OAuth ${token}` };\n    if (bodyBufOrNull) {\n      headers['Content-Type'] = 'application/json';\n      headers['Content-Length'] = String(bodyBufOrNull.length);\n    }\n\n    const r = await httpsRequestBuffer('botapi.messenger.yandex.net', apiPath, method, headers, bodyBufOrNull);\n    debug.push({ method, apiPath, status: r.statusCode, ct: String(r.headers['content-type'] || ''), head: preview(r.buf, 220), bytes: r.buf ? r.buf.length : 0 });\n\n    if (r.statusCode >= 200 && r.statusCode < 300) {\n      if (looksLikeJson(r.headers, r.buf)) {\n        const obj = tryParseJson(r.buf);\n        if (!obj) throw new Error('getFile: JSON not parseable');\n        if (obj.ok === false) throw new Error(obj.description || obj.code || 'getFile ok=false');\n\n        const url = obj.url || obj.file_url || obj.download_url;\n        if (url) return { buf: await downloadByUrl.call(this, url), debug };\n\n        const b64 = obj.data_b64 || obj.file_b64 || obj.base64;\n        if (b64 && typeof b64 === 'string') return { buf: Buffer.from(b64, 'base64'), debug };\n\n        throw new Error('getFile: JSON has no url/base64');\n      }\n\n      if (r.buf && r.buf.length) return { buf: r.buf, debug };\n      throw new Error('getFile: empty body');\n    }\n\n    const obj = looksLikeJson(r.headers, r.buf) ? tryParseJson(r.buf) : null;\n    if (obj && obj.ok === false) throw new Error(obj.description || obj.code || `getFile HTTP ${r.statusCode}`);\n    throw new Error(`getFile HTTP ${r.statusCode}`);\n  }\n\n  const postPaths = ['/bot/v1/messages/getFile/', '/bot/v1/files/getFile/'];\n  for (const p of postPaths) { try { return await attempt.call(this, 'POST', p, body); } catch {} }\n\n  const getPaths = [\n    `/bot/v1/messages/getFile/?file_id=${encodeURIComponent(fileId)}`,\n    `/bot/v1/files/getFile/?file_id=${encodeURIComponent(fileId)}`\n  ];\n  for (const p of getPaths) { try { return await attempt.call(this, 'GET', p, null); } catch {} }\n\n  const err = new Error('getFile failed');\n  err._getfile_debug = debug;\n  throw err;\n}\n\nfunction errDataToString(e) {\n  try {\n    const d = e?.response?.data;\n    if (d == null) return '';\n    if (Buffer.isBuffer(d)) return d.toString('utf8').slice(0, 2500);\n    if (typeof d === 'string') return d.slice(0, 2500);\n    return JSON.stringify(d).slice(0, 2500);\n  } catch {\n    return '';\n  }\n}\n\nfunction statusFromErr(e) {\n  const st = e?.response?.status ?? e?.statusCode ?? null;\n  if (st != null) return String(st);\n  const m = String(e?.message || '').match(/status code\\s*(\\d+)/i);\n  return m ? m[1] : '';\n}\n\n// ---- MAIN ----\nconst files = parseFiles(base.files);\nconst chosen = pickNonImage(files);\nif (!chosen) return [{ json: { ...base, _pdf_skip: true } }];\n\nconst fileId = s(chosen.file_id || chosen.id).trim();\nconst fileName = s(chosen.name || 'document.pdf').trim() || 'document.pdf';\n\nlet pdfBuf, getDbg;\ntry {\n  const got = await yandexGetFileBuffer.call(this, fileId);\n  pdfBuf = got.buf;\n  getDbg = got.debug;\n} catch (e) {\n  return [{\n    json: {\n      ...base,\n      _chitalka_no_doc: true,\n      error: `Не смог скачать файл: ${e.message || e}`,\n      error_data: '',\n      _getfile_debug: e._getfile_debug || [],\n    }\n  }];\n}\n\n// sanity: must be PDF\nconst head5 = pdfBuf && pdfBuf.length >= 5 ? pdfBuf.slice(0,5).toString('utf8') : '';\nif (head5 !== '%PDF-') {\n  return [{\n    json: {\n      ...base,\n      _chitalka_no_doc: true,\n      error: 'Скачанный payload не похож на PDF (%PDF- header отсутствует)',\n      error_data: `head_utf8=\"${pdfBuf ? pdfBuf.slice(0,80).toString('utf8') : ''}\" head_hex=\"${pdfBuf ? pdfBuf.slice(0,16).toString('hex') : ''}\" bytes=${pdfBuf ? pdfBuf.length : 0}`,\n      _getfile_debug: getDbg || [],\n    }\n  }];\n}\n\nconst lang = (base.forceOcrEn === true) ? 'en' : 'ru';\nconst pdfB64 = pdfBuf.toString('base64');\n\nlet resp;\ntry {\n  resp = await this.helpers.httpRequest({\n    method: 'POST',\n    url: PDF_EXTRACT_URL,\n    json: true,\n    timeout: 600000,\n    body: { lang, pdf_b64: pdfB64 },\n  });\n} catch (e) {\n  const status = statusFromErr(e);\n  const dataStr = errDataToString(e) || '(no response body)';\n  return [{\n    json: {\n      ...base,\n      _chitalka_no_doc: true,\n      error: `PDF extract failed status=${status} ${e?.message || e}`,\n      error_data: dataStr,\n      _getfile_debug: getDbg || [],\n      _pdf_send_debug: { bytes: pdfBuf.length, head_utf8: pdfBuf.slice(0,8).toString('utf8'), head_hex: pdfBuf.slice(0,8).toString('hex') }\n    }\n  }];\n}\n\nif (!resp || resp.ok !== true) {\n  return [{\n    json: {\n      ...base,\n      _chitalka_no_doc: true,\n      error: 'PDF обработчик вернул ошибку',\n      error_data: JSON.stringify(resp || {}).slice(0, 2500),\n      _getfile_debug: getDbg || [],\n    }\n  }];\n}\n\nconst text = String(resp.text || '').trim();\nif (!text) {\n  return [{\n    json: {\n      ...base,\n      _chitalka_no_doc: true,\n      error: 'PDF обработан, но текст пустой.',\n      error_data: JSON.stringify(resp || {}).slice(0, 2500),\n      _getfile_debug: getDbg || [],\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    ...base,\n    source_file_name: fileName,\n    ocr_text: text,\n    _pdf_ok: true,\n    _pdf_debug: { method: resp.method, page_count: resp.page_count ?? null },\n    _getfile_debug: getDbg || [],\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        -32
      ],
      "id": "4816cb2c-2a74-4da8-a7e0-f97a60fd8c41",
      "name": "Chitalka Extract PDF/TXT"
    },
    {
      "parameters": {
        "jsCode": "// Chitalka Build Output — FULL REPLACE v2.0 (NO PDF tools here; errors -> text, success -> file)\n// LOGIN-only routing (no chat_id)\n// If there is an error (_chitalka_no_doc / error / error_data) -> return json.text (no binary)\n// If success -> build Word (.doc HTML) or CSV (.csv)\n\nfunction s(x){ return x == null ? '' : String(x); }\n\nfunction toSafeBaseName(s0, fallback) {\n  const raw = (s0 || '').toString().trim();\n  const base = raw.slice(0, 80) || fallback;\n  return (base\n    .replace(/[\\/:*?\"<>|]+/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim()\n    .slice(0, 80)) || fallback;\n}\n\nfunction escapeHtml(text){\n  return String(text||'')\n    .replace(/&/g,'&amp;')\n    .replace(/</g,'&lt;')\n    .replace(/>/g,'&gt;')\n    .replace(/\\\"/g,'&quot;');\n}\n\nfunction underlineAccentsToHtml(text){\n  // underline \"letter + combining acute (U+0301)\"\n  return String(text || '').replace(/([A-Za-zА-Яа-яЁё])\\u0301/g, '<u>$1\\u0301</u>');\n}\n\nfunction wantsExcel(userText){\n  return /(excel|эксель|xlsx|csv|таблиц(а|у)|в\\s*эксель|в\\s*excel)/i.test(String(userText||''));\n}\nfunction wantsWord(userText){\n  return /(word|ворд|docx?|в\\s*word|в\\s*ворд|в\\s*docx|документ)/i.test(String(userText||''));\n}\n\nfunction formatErr(base){\n  const parts = [];\n  if (base._chitalka_no_doc) parts.push('Chitalka: не удалось обработать документ.');\n  if (base.error) parts.push(`Error: ${s(base.error).slice(0, 900)}`);\n  if (base.error_data) parts.push(`Details: ${s(base.error_data).slice(0, 1400)}`);\n  if (base._pdf_debug) parts.push(`PDF debug: ${JSON.stringify(base._pdf_debug).slice(0, 1400)}`);\n  if (base.ocr_debug) parts.push(`OCR debug: ${JSON.stringify(base.ocr_debug).slice(0, 1400)}`);\n  if (!parts.length) parts.push('Chitalka: ошибка обработки документа.');\n  return parts.join('\\n');\n}\n\nconst base = $input.item.json || {};\nconst login = s(base.login).trim();\n\n// silent if no login\nif (!login) return [{ json: { _stop: true } }];\n\n// If any error flags -> send as text (no file)\nconst hasError =\n  !!base.error ||\n  !!base.error_data ||\n  base._chitalka_no_doc === true ||\n  (typeof base.ocr_text === 'string' && base.ocr_text.includes('[OCR ERROR]'));\n\nif (hasError) {\n  return [{\n    json: {\n      login,\n      text: formatErr(base),\n      _sendAsText: true\n    }\n  }];\n}\n\nconst userReq = s(base.lastUserText || base.text || '').trim();\nconst excel = wantsExcel(userReq) && !wantsWord(userReq);\n\n// filename\nconst srcName = s(base.source_file_name || 'document').trim();\nconst baseName = toSafeBaseName(srcName.replace(/\\.[^.]+$/,''), 'document');\n\n// Prefer VLM (main), then norm_text, then OCR\nconst vlmText  = s(base.vlm_text || (base.vlm_json && base.vlm_json.normalized_text) || '').trim();\nconst normText = s(base.norm_text || '').trim();\nconst ocrText  = s(base.ocr_text || base.extracted_text || '').trim();\nconst docText  = (vlmText || normText || ocrText || '').trim();\n\nif (!docText) {\n  return [{\n    json: { login, text: 'Chitalka: извлечённый текст пустой.', _sendAsText: true }\n  }];\n}\n\n// Excel -> CSV with BOM\nif (excel) {\n  const csv = '\\uFEFF' + docText;\n  const buff = Buffer.from(csv, 'utf8');\n  return [{\n    json: { login, text: 'OK' },\n    binary: {\n      file: {\n        data: buff.toString('base64'),\n        fileName: `${baseName}.csv`,\n        mimeType: 'text/csv'\n      }\n    }\n  }];\n}\n\n// Word -> .doc as HTML\nconst htmlBody = underlineAccentsToHtml(escapeHtml(docText));\nconst html = `<!DOCTYPE html><html><head><meta charset=\"UTF-8\"></head><body style=\"font-family:Calibri,Arial,sans-serif; white-space:pre-wrap;\">${htmlBody}</body></html>`;\nconst buff = Buffer.from(html, 'utf8');\n\nreturn [{\n  json: { login, text: 'OK' },\n  binary: {\n    file: {\n      data: buff.toString('base64'),\n      fileName: `${baseName}.doc`,\n      mimeType: 'application/msword'\n    }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2048,
        -192
      ],
      "id": "2a63bd49-7325-4e59-8a3a-48b3dd4da367",
      "name": "Chitalka Build Output"
    },
    {
      "parameters": {
        "jsCode": "// Parse files + classify — FULL REPLACE v2 (adds route) 111\n// Output fields:\n// - files: array\n// - hasFile/hasImage/hasNonImage/hasImageOnly\n// - route: \"ocr\" | \"nonimage\" | \"none\"\n// - route_reason: string\n\nfunction parseFiles(v) {\n  if (!v) return [];\n  if (Array.isArray(v)) return v;\n  if (typeof v === 'string') {\n    try {\n      const a = JSON.parse(v);\n      return Array.isArray(a) ? a : [];\n    } catch {\n      return [];\n    }\n  }\n  return [];\n}\n\nfunction isImage(f) {\n  if (!f || typeof f !== 'object') return false;\n  const kind = String(f.kind || '').toLowerCase();\n  if (kind === 'image') return true;\n  const name = String(f.name || '').toLowerCase();\n  return /\\.(png|jpg|jpeg|bmp|gif|tif|tiff|webp)$/i.test(name);\n}\n\nfunction isAudio(f) {\n  if (!f || typeof f !== 'object') return false;\n  const kind = String(f.kind || '').toLowerCase();\n  if (kind === 'audio') return true;\n  const name = String(f.name || '').toLowerCase();\n  return /\\.(ogg|opus|mp3|wav|m4a|aac|flac)$/i.test(name);\n}\n\nconst items = $input.all();\n\nfor (const it of items) {\n  const row = it.json || {};\n\n  const raw = row.files;\n  const arr = parseFiles(raw);\n\n  row.files_raw = (typeof raw === 'string') ? raw : null;\n  row.files = arr;\n\n  row.hasFile = arr.length > 0;\n  row.hasImage = arr.some(isImage);\n  row.hasNonImage = arr.some(f => !isImage(f) && !isAudio(f));\n  row.hasImageOnly = row.hasImage === true && row.hasNonImage === false;\n\n  // route decision\n  if (!row.hasFile) {\n    row.route = 'none';\n    row.route_reason = 'no attachments';\n  } else if (row.hasImageOnly) {\n    row.route = 'ocr';\n    row.route_reason = 'images only';\n  } else {\n    // any non-image OR mixed -> go nonimage (PDF/TXT branch)\n    row.route = 'nonimage';\n    row.route_reason = row.hasNonImage ? 'non-image attachment present' : 'mixed attachments';\n  }\n\n  it.json = row;\n}\n\nreturn items;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        48,
        -192
      ],
      "id": "5d706fd2-fc59-4f08-8c67-301ea4b4b6e3",
      "name": "Parse files + classify"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "9762fa70-8640-4f1b-9966-3e747cacf98f",
              "leftValue": "={{ $json.hasFile === true }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        384,
        -192
      ],
      "id": "f4827e2e-1fb6-4067-a947-c91647a7c767",
      "name": "If  files"
    },
    {
      "parameters": {
        "jsCode": "// OCR Cleanup (Text LLM) — FULL REPLACE v1\n// Input: base.ocr_text (from Merge OCR results)\n// Output: base.norm_text (cleaned), preserves chatId/login\n\nconst base = $input.item.json || {};\nfunction s(x){ return x == null ? '' : String(x); }\n\nconst OLLAMA_URL = (String($env.OLLAMA_URL || 'http://host.docker.internal:11434')).replace(/\\/$/, '');\nconst MODEL = String($env.CHITALKA_TEXT_MODEL || 'qwen2.5:32b-instruct-q8_0').trim() || 'qwen2.5vl:72b-q8_0';\n\nconst ocr = s(base.ocr_text).trim();\nif (!ocr) return [{ json: { ...base, norm_text: '' } }];\n\nconst prompt =\n`Ты — модуль очистки OCR (НЕ чатбот).\nЗадача: исправить ОЧЕВИДНЫЕ OCR-артефакты, не меняя смысл.\n\nПравила:\n- Убрать дубли слогов/букв из OCR (например: \"Словарарный\" -> \"Словарный\", \"Сино́нимимы\" -> \"Сино́нимы\").\n- Исправлять только явные орфографические ошибки (по-русски).\n- Сохранить пунктуацию, запятые, переносы строк.\n- Сохранить ударения (символ U+0301) там, где они уже есть в тексте.\n- Ничего не добавлять от себя.\n- ВЫВЕСТИ ТОЛЬКО ИСПРАВЛЕННЫЙ ТЕКСТ (без пояснений, без JSON).\n\nOCR_TEXT:\n${ocr.slice(0, 20000)}\n`;\n\nlet resp;\ntry {\n  resp = await this.helpers.httpRequest({\n    method: 'POST',\n    url: `${OLLAMA_URL}/api/chat`,\n    json: true,\n    timeout: 3600000,\n    body: {\n      model: MODEL,\n      stream: false,\n      options: { temperature: 0, top_p: 1, top_k: 1 },\n      messages: [{ role: 'user', content: prompt }],\n    }\n  });\n} catch (e) {\n  const status = e?.response?.status || e?.statusCode || '';\n  return [{ json: { ...base, norm_text: ocr, _norm_error: `LLM fail status=${status} ${e?.message || e}` } }];\n}\n\nlet out = String(resp?.message?.content || '').trim();\nout = out.replace(/^```[\\w-]*\\s*/i,'').replace(/```$/,'').trim();\n\nreturn [{\n  json: {\n    ...base,\n    norm_text: out || ocr,\n    norm_model: MODEL,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1616,
        -336
      ],
      "id": "b76dd262-4aab-46dd-90a7-2e642876d885",
      "name": "OCR Cleanup"
    }
  ],
  "pinData": {
    "Webhook": [
      {
        "json": {
          "headers": {
            "connection": "upgrade",
            "host": "n8n.itcost.ru",
            "x-real-ip": "10.10.200.1",
            "x-forwarded-for": "10.10.200.1",
            "x-forwarded-proto": "https",
            "content-length": "375",
            "user-agent": "Mozilla/5.0 (compatible; YandexUserproxy; robot; +http://yandex.com/bots)",
            "accept-encoding": "gzip, x-gzip, deflate",
            "content-type": "application/json; charset=UTF-8"
          },
          "params": {},
          "query": {},
          "body": {
            "updates": [
              {
                "message_id": 1763730909592004,
                "timestamp": 1763730909,
                "chat": {
                  "type": "private"
                },
                "from": {
                  "id": "360eed3e-84b1-40cd-8af5-f9042df164ad",
                  "display_name": "Кузин Евгений",
                  "login": "kuzin@itcost.ru",
                  "robot": false
                },
                "update_id": 1763730909592004,
                "text": "Как сам?"
              }
            ]
          },
          "webhookUrl": "http://localhost:5678/webhook/Assistbot",
          "executionMode": "production"
        }
      }
    ]
  },
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Extract message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract message": {
      "main": [
        [
          {
            "node": "Data message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Data message": {
      "main": [
        [
          {
            "node": "Read messages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read messages": {
      "main": [
        [
          {
            "node": "Parse files + classify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare files for OCR": {
      "main": [
        [
          {
            "node": "OCR Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge OCR results": {
      "main": [
        [
          {
            "node": "OCR Cleanup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If file": {
      "main": [
        [
          {
            "node": "Send file",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Files go OCR": {
      "main": [
        [
          {
            "node": "Prepare files for OCR",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Chitalka Extract PDF/TXT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "VLM Normalize (Qwen2.5-VL)": {
      "main": [
        [
          {
            "node": "Chitalka Build Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OCR Request": {
      "main": [
        [
          {
            "node": "Merge OCR results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chitalka Extract PDF/TXT": {
      "main": [
        [
          {
            "node": "Chitalka Build Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chitalka Build Output": {
      "main": [
        [
          {
            "node": "If file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse files + classify": {
      "main": [
        [
          {
            "node": "If  files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If  files": {
      "main": [
        [
          {
            "node": "Update row(s)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Files go OCR",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Stop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OCR Cleanup": {
      "main": [
        [
          {
            "node": "VLM Normalize (Qwen2.5-VL)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "timezone": "Europe/Moscow",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "versionId": "7a6c8497-19f0-4d9f-9e40-fa09f9eec92a",
  "meta": {
    "instanceId": "b7aa380705656969fa39759e0868f4a2cdd733e71248db37848cd014e207c2bc"
  },
  "id": "Yk2Fx2gJxmI4POjt",
  "tags": []
}
